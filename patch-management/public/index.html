<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patch Management</title>
    <link rel="stylesheet" href="styles.css">
    </head>
<body>

<header>
    <h1>Patch Management Dashboard</h1>
    <div class="user-info">
        Willkommen, <span id="currentUsername"></span> |
        <button id="userManagementButton" style="display: none;" onclick="openUserManagementPopup()">
            üë• Benutzerverwaltung
        </button>
        <button id="changePasswordButton">Passwort √§ndern</button>
        <button onclick="handleLogout()">Abmelden</button>
    </div>
</header>

<div id="adminArea" style="display: none;">
    <h2>‚öôÔ∏è Benutzerverwaltung (Admin)</h2>
    <div id="userManagementSection">
        </div>
    <hr>
</div>



    <div class="container">
        <button class="action-button" onclick="openAddServerPopup()">‚ûï Server hinzuf√ºgen</button>
        <div style="display: inline-block; position: absolute; top: 90px; right: 5px; ">
            <label style="display: block; margin-bottom: 5px; font-weight: bold;">Bootstrap Befehl:</label>
            <textarea id="bootstrapCommandField" readonly style="padding: 10px; width:500px;background-color: #d3d3d3; color: #000; border: 1px solid #999; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 12px; resize: none; overflow: hidden; white-space: nowrap;">Wird geladen...</textarea>
        </div>

        <table id="zustandTable">
            <thead>
                <tr>
                    <th>Server</th>
                    <th>Debian Version</th>
                    <th>Zust√§ndig</th>
                    <th>Possible Updates</th>
                    <th>Root Free</th>
                    <th>Last Run</th>
                    <th>Aktion</th>
                    <th width=10px>l&ouml;schen</th>
                    <th>Kommentar</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>

    <div id="updatePopup" class="popup" style="display: none;">
        <div class="popup-content">
            <span id="closePopup" onclick="closePopup()">&times;&nbsp;&nbsp;</span>
            <h2>Updateprozess</h2>
            <pre id="updateLog">Verbinde...</pre>
        </div>
    </div>

    <div id="selectUpdatePopup" class="popup" style="display: none;">
        <div class="popup-content" style="display: flex; flex-direction: column; height: 100%;">
            <span id="closeSelectPopup" onclick="closeSelectPopup()">&times;&nbsp;&nbsp;</span>
            
            <!-- Fixed Header -->
            <div style="position: sticky; top: 0; background: #333; padding: 0 0 15px 0; z-index: 100; border-bottom: 1px solid #555;">
                <h2 id="selectUpdateServerTitle" style="margin: 0; padding: 15px 0 0 0;">Updates f√ºr Server:</h2>
            </div>

            <!-- Scrollable Table Container -->
            <div style="flex: 1; overflow-y: auto; margin: 15px 0;">
                <table id="updateTable">
                    <thead>
                        <tr>
                            <th>Auswahl</th>
                            <th>Paket</th>
                            <th>Aktuelle Version</th>
                            <th>Update auf Version</th>
                        </tr>
                    </thead>
                    <tbody id="updateCheckboxes">
                        </tbody>
                </table>
            </div>

            <!-- Fixed Footer -->
            <div style="position: sticky; bottom: 0; background: #333; padding: 15px 0 0 0; border-top: 1px solid #555;">
                <button class="action-button" onclick="startSelectedUpdate()">Ausgew√§hlte Updates installieren</button>
                <p id="selectedUpdateError" style="color: red; display: none; margin-top: 10px;">Bitte w√§hlen Sie mindestens ein Update aus.</p>
            </div>
        </div>
    </div>

    <div id="addServerPopup" class="popup" style="display: none;">
        <div class="popup-content">
            <span onclick="closeAddServerPopup()">&times;&nbsp;&nbsp;</span>
            <h2>Neuen Server hinzuf√ºgen</h2>
            <input type="text" id="newServerIp" placeholder="IP-Adresse des Clients (z.B. 192.168.1.10)" required>
            <button class="action-button" onclick="addAndConnectServer()">Server hinzuf√ºgen & Verbinden</button>
            <p id="addServerError" style="color: red; display: none; margin-top: 10px;">Bitte geben Sie eine g√ºltige IP-Adresse ein.</p>
        </div>
    </div>

    <div id="schedulePopup" class="popup" style="display: none;">
        <div class="popup-content">
            <span id="closeSchedulePopupBtn" onclick="closeSchedulePopup()">&times;&nbsp;&nbsp;</span>
            <h2 id="scheduleServerTitle">Intervall f√ºr Server:</h2>
            <input type="hidden" id="scheduleServerId">
            <input type="hidden" id="scheduleServerIp">

            <div class="schedule-options">
                <label>
                    <input type="radio" name="scheduleType" value="hourly" onchange="toggleScheduleOptions()"> St√ºndlich
                </label><br>
                <label>
                    <input type="radio" name="scheduleType" value="daily" onchange="toggleScheduleOptions()"> T√§glich um
                    <input type="time" id="dailyTime" value="03:00" disabled> Uhr
                </label><br>
                <label>
                    <input type="radio" name="scheduleType" value="weekly" onchange="toggleScheduleOptions()"> Jeden
                    <select id="weeklyDay" disabled style="width: 150px; padding: 5px;">
                        <option value="0">Sonntag</option>
                        <option value="1">Montag</option>
                        <option value="2">Dienstag</option>
                        <option value="3">Mittwoch</option>
                        <option value="4">Donnerstag</option>
                        <option value="5">Freitag</option>
                        <option value="6">Samstag</option>
                    </select>
                    um
                    <input type="time" id="weeklyTime" value="04:00" disabled> Uhr
                </label>
            </div>

            <button class="action-button" onclick="saveSchedule()">Intervall speichern</button>
            <p id="scheduleStatus" style="color: green; margin-top: 10px;"></p>
        </div>
    </div>

    <div id="changePasswordPopup" class="popup" style="display: none;">
    <div class="popup-content">
        <span id="closeChangePasswordPopupBtn" onclick="closeChangePasswordPopup()">&times;&nbsp;&nbsp;</span>
        <h2>Passwort √§ndern</h2>
        <input type="password" id="oldPassword" placeholder="Altes Passwort" required style="margin-bottom: 10px;">
        <input type="password" id="newPassword" placeholder="Neues Passwort" required style="margin-bottom: 10px;">
        <input type="password" id="confirmNewPassword" placeholder="Neues Passwort best√§tigen" required style="margin-bottom: 10px;">
        <button class="action-button" onclick="submitChangePassword()">Passwort aktualisieren</button>
        <p id="passwordChangeStatus" style="color: red; margin-top: 10px;"></p>
    </div>
</div>

<div id="userManagementPopup" class="popup" style="display: none;">
    <div class="popup-content">
        <span id="closeUserManagementPopupBtn" onclick="closeUserManagementPopup()">&times;&nbsp;&nbsp;</span>
        <h2>üë• Benutzerverwaltung</h2>

        <h3>Neuen Benutzer anlegen</h3>
        <input type="text" id="newUsername" placeholder="Benutzername" required style="margin-bottom: 10px;">
        <input type="password" id="newUserPassword" placeholder="Passwort" required style="margin-bottom: 10px;">
        <label>
            <input type="checkbox" id="newUserIsAdmin"> Administrator
        </label>
        <button class="action-button" onclick="createUser()">Benutzer erstellen</button>
        <p id="userCreationStatus" style="color: red; margin-top: 10px;"></p>

        <hr>

        <h3>Bestehende Benutzer l√∂schen</h3>
        <table id="userTable">
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Benutzername</th>
                    <th>Admin</th>
                    <th>Aktion</th>
                </tr>
            </thead>
            <tbody id="userTableBody">
                </tbody>
        </table>
    </div>
</div>


    <script>
        let ws;
        let currentServerRow; // Speichert die IP und ID des aktuell ausgew√§hlten Servers


        // ========== DRAG & DROP FUNKTIONALIT√ÑT F√úR POPUPS ==========
// F√ºge dies direkt nach dem <script> Tag ein

let draggedElement = null;
let offsetX = 0;
let offsetY = 0;

function makeDraggable(popupContent) {
    const header = popupContent.querySelector('h2');
    if (!header) return;

    header.style.cursor = 'move';
    header.style.userSelect = 'none';
    header.addEventListener('mousedown', startDrag);
}

function startDrag(e) {
    // √Ñndere dies: Greife das √§u√üerste .popup-Element
    draggedElement = e.target.closest('.popup');

    if (!draggedElement) return;

    const rect = draggedElement.getBoundingClientRect();
    offsetX = e.clientX - rect.left;
    offsetY = e.clientY - rect.top;

    // *** WICHTIGSTE ANPASSUNG: Entferne die CSS-Zentrierung! ***
    draggedElement.style.transform = 'none';

    // Setze die aktuelle Position als absolute left/top Werte,
    // damit das Verschieben nahtlos beginnt
    draggedElement.style.left = rect.left + 'px';
    draggedElement.style.top = rect.top + 'px';

    // Stelle sicher, dass es 'fixed' oder 'absolute' ist
    draggedElement.style.position = 'fixed';

    draggedElement.style.opacity = '0.8';
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', stopDrag);
}

function drag(e) {
    if (!draggedElement) return;

    let newX = e.clientX - offsetX;
    let newY = e.clientY - offsetY;

    // Begrenzung auf Browserfenster
    const maxX = window.innerWidth - draggedElement.offsetWidth;
    const maxY = window.innerHeight - draggedElement.offsetHeight;

    newX = Math.max(0, Math.min(newX, maxX));
    newY = Math.max(0, Math.min(newY, maxY));

    // Die Positionierung funktioniert jetzt, da 'transform' in startDrag entfernt wurde
    draggedElement.style.left = newX + 'px';
    draggedElement.style.top = newY + 'px';
    // draggedElement.style.transform = 'none'; // <- Diese Zeile ist jetzt nicht mehr n√∂tig
}

function stopDrag() {
    if (draggedElement) {
        draggedElement.style.opacity = '1';
        draggedElement = null;
    }
    document.removeEventListener('mousemove', drag);
    document.removeEventListener('mouseup', stopDrag);
}

// Initialisiere beim Laden
document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.popup-content').forEach(popup => {
        makeDraggable(popup);
    });
});


        // --- NEUE FUNKTIONEN F√úR SERVER HINZUF√úGEN ---

        function openAddServerPopup() {
            document.getElementById('newServerIp').value = '';
            document.getElementById('addServerError').style.display = 'none';
            document.getElementById('addServerPopup').style.display = 'block';
        }

        function closeAddServerPopup() {
            document.getElementById('addServerPopup').style.display = 'none';
        }

        async function addAndConnectServer() {
            const ip = document.getElementById('newServerIp').value.trim();
            const errorDisplay = document.getElementById('addServerError');

            // Einfache Validierung der IP-Adresse
            if (!/^(\d{1,3}\.){3}\d{1,3}$/.test(ip)) {
                errorDisplay.textContent = 'Bitte geben Sie eine g√ºltige IP-Adresse ein.';
                errorDisplay.style.display = 'block';
                return;
            }

            errorDisplay.style.display = 'none';
            closeAddServerPopup();

            // F√ºhrt zwei Aktionen nacheinander aus: addServer und connectSSH
            try {
                // 1. Server in die DB einf√ºgen
                await fetch('/api/addServer', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ip })
                });

                // 2. Direkt "Connect SSH" ausf√ºhren (startet die Datensammlung)
                await executeAction(ip, 'connectSSH');

                alert(`Server ${ip} wurde hinzugef√ºgt und Datensammlung gestartet. Bitte warten Sie einen Moment auf die Aktualisierung.`);
                loadZustand();
            } catch (error) {
                alert(`Fehler beim Hinzuf√ºgen/Verbinden von Server ${ip}.`);
                console.error(error);
                loadZustand();
            }
        }

        // --- NEUE FUNKTIONEN F√úR SCHEDULING ---

        function openSchedulePopup(id, ip, schedule) {
            document.getElementById('scheduleServerId').value = id;
            document.getElementById('scheduleServerIp').value = ip;
            document.getElementById('scheduleServerTitle').textContent = `Intervall f√ºr Server: ${ip}`;
            document.getElementById('scheduleStatus').textContent = '';

            // Setze die Radiobuttons basierend auf dem aktuellen Schedule
            let type = schedule.type || 'hourly';
            let time = schedule.time || '03:00';

            document.querySelector(`input[name="scheduleType"][value="${type}"]`).checked = true;

            // Setze die Uhrzeiten
            document.getElementById('dailyTime').value = time;
            document.getElementById('weeklyTime').value = time;

            toggleScheduleOptions(); // Aktiviert/Deaktiviert die Zeitfelder
            document.getElementById('schedulePopup').style.display = 'block';
        }

        function closeSchedulePopup() {
            document.getElementById('schedulePopup').style.display = 'none';
        }

        function toggleScheduleOptions() {
            const dailyChecked = document.querySelector('input[name="scheduleType"][value="daily"]').checked;
            const weeklyChecked = document.querySelector('input[name="scheduleType"][value="weekly"]').checked;

            document.getElementById('dailyTime').disabled = !dailyChecked;
            document.getElementById('weeklyTime').disabled = !weeklyChecked;
            document.getElementById('weeklyDay').disabled = !weeklyChecked;
        }

        async function saveSchedule() {
            const id = document.getElementById('scheduleServerId').value;
            const ip = document.getElementById('scheduleServerIp').value;
            const type = document.querySelector('input[name="scheduleType"]:checked').value;
            let time = '';
            let day = '';

            if (type === 'daily') {
                time = document.getElementById('dailyTime').value;
            } else if (type === 'weekly') {
                time = document.getElementById('weeklyTime').value;
                day = document.getElementById('weeklyDay').value;
            }

            try {
                await fetch('/api/schedule', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id, ip, type, time, day })
                });

                document.getElementById('scheduleStatus').textContent = 'Intervall erfolgreich gespeichert.';
                // Optional: Popup nach kurzer Zeit schlie√üen oder Tabelle neu laden
                setTimeout(() => {
                    closeSchedulePopup();
                    loadZustand();
                }, 1500);

            } catch (error) {
                document.getElementById('scheduleStatus').textContent = 'Fehler beim Speichern des Intervalls.';
                console.error(error);
            }
        }

        // --- BESTEHENDE FUNKTIONEN (kleine Anpassung in renderAction) ---

        // Funktion zum √ñffnen des Log-Popups
        function openPopup() {
            document.getElementById('updatePopup').style.display = 'block';
        }

        // Funktion zum Schlie√üen des Log-Popups
        function closePopup() {
            document.getElementById('updatePopup').style.display = 'none';
            if (ws) ws.close(); // Schlie√üe die WebSocket-Verbindung
        }

        // NEU: Funktion zum √ñffnen des Select-Update-Popups mit Tabellenerstellung
  async function openSelectPopup(ip, updates, id) {
            currentServerRow = { ip, id };
            document.getElementById('selectUpdateServerTitle').textContent = `Updates f√ºr Server: ${ip}`;

            const tableBody = document.getElementById('updateCheckboxes');
            tableBody.innerHTML = '<tr><td colspan="4">Lade Schwachstellendaten...</td></tr>';

            // Schwachstellendaten vom Server abrufen
            let vulnerabilities = [];
            try {
                const response = await fetch(`/api/vulnerableUpdates/${id}`);
                const data = await response.json();
                if (data.success && data.vulnerabilities) {
                    vulnerabilities = data.vulnerabilities;
                }
            } catch (error) {
                console.error('Fehler beim Laden der Schwachstellendaten:', error);
            }

            // Tabelle leeren und neu bef√ºllen
            tableBody.innerHTML = '';

            const updateRegex = /^(\S+?)(?:\/\S+)?\s+(\S+).*?\[(?:aktualisierbar von|upgradable from):\s+(\S+)\]/;

            updates.forEach((updateLine) => {
                const match = updateLine.match(updateRegex);

                let packageName = 'Unbekannt';
                let oldVersion = 'N/A';
                let newVersion = 'N/A';
                let updateValue = updateLine.split(' ')[0];

                if (match) {
                    packageName = match[1];
                    newVersion = match[2].split(' ')[0];
                    oldVersion = match[3];
                    updateValue = packageName;
                }

                // Pr√ºfen, ob es eine Schwachstelle f√ºr dieses Paket gibt
                const vulnerability = vulnerabilities.find(v => v.package_name === packageName);

                // Hintergrundfarbe basierend auf der Risikostufe festlegen
                let backgroundColor = '#000000'; // Gr√ºn als Standard (kein bekanntes Risiko)
                let titleText = 'Keine bekannten Schwachstellen';

                if (vulnerability) {
                    const priority = vulnerability.priority_level ? vulnerability.priority_level.toLowerCase() : '';

                    if (priority === 'high') {
                        backgroundColor = '#C03030'; // Rot
                        titleText = `CVE: ${vulnerability.cve_id} - HIGH RISK - ${vulnerability.description || ''}`;
                    } else if (priority === 'medium') {
                        backgroundColor = '#E58022'; // Orange/Gelb
                        titleText = `CVE: ${vulnerability.cve_id} - MEDIUM RISK - ${vulnerability.description || ''}`;
                    } else if (priority === 'end-of-life' || priority === 'eol') {
                        backgroundColor = '#ACA6A6'; // Grau
                        titleText = `CVE: ${vulnerability.cve_id} - END-OF-LIFE - ${vulnerability.description || ''}`;
                    }
                }

                const tr = document.createElement('tr');
                tr.style.backgroundColor = backgroundColor;
                tr.title = titleText;

                tr.innerHTML = `
                    <td>
                        <input type="checkbox" name="selectedUpdate" value="${updateValue}" checked>
                    </td>
                    <td>${packageName}</td>
                    <td>${oldVersion}</td>
                    <td>${newVersion}</td>
                `;

                tableBody.appendChild(tr);
            });

            document.getElementById('selectUpdatePopup').style.display = 'block';
        }

        // Funktion zum Schlie√üen des Select-Update-Popups
        function closeSelectPopup() {
            document.getElementById('selectedUpdateError').style.display = 'none';
            document.getElementById('selectUpdatePopup').style.display = 'none';
            currentServerRow = null;
        }

        // Funktion zum automatischen Scrollen nach unten
        function scrollToBottom() {
            const log = document.getElementById('updateLog');
            log.scrollTop = log.scrollHeight;
        }

        // Funktion zum Laden der Zustandsdaten und zum Rendern der Tabelle
        async function loadZustand() {
            const response = await fetch('/api/zustand');
            const zustandList = await response.json();
            const tableBody = document.querySelector('#zustandTable tbody');
            tableBody.innerHTML = '';

            zustandList.forEach(row => {
                const tr = document.createElement('tr');
                if (parseInt(row.pu) >= 1) tr.classList.add('highlight-row');

                tr.innerHTML = `
                    <td style="position: relative; padding-bottom: 35px; padding-top: 40px;">
                        <span style="display: inline-block; position: absolute; top: 5px; right: 5px; cursor: pointer;" title="Restore SSH Autoconnect" onclick="restoreSSHKey('${row.server}', ${row.id})">
                            <span style="font-size: 12px;">üîë</span>
                        </span>
                        <span style="display: inline-block; position: absolute; top: 5px; left: 5px; cursor: pointer;" title="Daten aktualisieren" onclick="collectDataManually('${row.server}', ${row.id})">
                            <span style="font-size: 18px; color: #ff9800;"><b>‚ü≥</b></span>
                        </span>
                        <span style="display: inline-block; position: absolute; bottom: 5px; left: 5px; cursor: pointer;" title="configure sheduling" onclick="openSchedulePopup(${row.id}, '${row.server}', { type: '${row.schedule_type || ''}', time: '${row.schedule_time || ''}' })">
                            <span style="font-size: 18px;">‚öôÔ∏è</span>
                        </span>
                        <span style="display: inline-block; position: absolute; bottom: 5px; right: 5px; cursor: pointer;" title="open remote Shell" onclick="openRemoteConsole('${row.server}')">
                            <span style="font-size: 18px;">üñ•Ô∏è</span>
                        </span><center><b>
                        ${row.server}</b></center
                    </td>
                    <td>${row.sys}</td>
                    <td>
                        <textarea onchange="saveText(${row.id}, 'zus', this.value)">${row.zus}</textarea>
                    </td>
                    <td>${row.pu}</td>
                    <td>${row.root_free}</td>
                    <td>${formatdate(row.last_run)}</td>
                    <td>${renderAction(row)}</td>
                    <td>
                        <textarea onchange="saveText(${row.id}, 'komment', this.value)">${row.komment}</textarea>
                    </td>
                `;
                tableBody.appendChild(tr);
            });
        }

        // Funktion zum Speichern von √Ñnderungen in den Feldern "zus" und "komment"
        async function saveText(id, field, value) {
            await fetch('/api/update', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id, field, value })
            });
        }

        // Funktion zur Formatierung des last_run in die gew√ºnschte Darstellung
        function formatdate(last_run) {
            if (!last_run) return 'N/A';
            return last_run.split('.')[0].replace('T', ' ');
        }

        // Funktion zur Darstellung der Action-Buttons (Update, SSH, L√∂schen)
        function renderAction(row) {
            const ip = row.server;
            const updatesAvailable = parseInt(row.pu);
            const inLogFile = row.inLogFile;

            let actionButtons = '';

            if (!inLogFile) {
                // NEU: Beim Hinzuf√ºgen eines Servers soll dies nur der Initial-Schritt sein
                //actionButtons += `<table id=at><tr><td><button class="action-button" onclick="executeAction('${ip}', 'connectSSH')">Connect SSH</button></td>`;
            } else if (inLogFile && updatesAvailable === 0) {
                actionButtons += '<table id=at><tr></tr></table>';
            } else if (inLogFile && updatesAvailable >= 1) {
                actionButtons += `<table id=at><tr><td><button class="action-button" onclick="selupd('${ip}', ${row.id})">Select Updates</button>&ensp;&ensp;&ensp;<button class="action-button" onclick="updateServer('${ip}')">Update FULL Server</button></td></tr></table>`;
            }

            // Server l√∂schen-Button hinzuf√ºgen
            actionButtons += `<td><button title="Server l&ouml;schen" class="del-button delete-button" onclick="deleteServer(${row.id}, '${row.server}')"><img src="/images/del.png" alt="del-img"></button></td>`;

            return actionButtons;
        }

        // Funktion zum L√∂schen eines Servers mit Best√§tigung
        async function deleteServer(id, server) {
            const confirmation = confirm(`Soll der Server ${server} wirklich entfernt werden?`);
            if (confirmation) {
                await fetch('/api/deleteServer', {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id })
                });
                loadZustand(); // Tabelle aktualisieren
            }
        }

        // Funktion zum manuellen Datensammeln von einem Server
        async function collectDataManually(ip, id) {
            const statusEl = document.createElement('div');
            statusEl.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #333;
                color: #0f0;
                padding: 20px;
                border-radius: 8px;
                z-index: 9999;
                text-align: center;
                font-family: monospace;
                min-width: 300px;
            `;
            statusEl.innerHTML = `<div>Sammle Daten von ${ip}...</div><div style="margin-top: 15px; font-size: 14px; color: #aaa;">Bitte warten...</div>`;
            document.body.appendChild(statusEl);

            try {
                const response = await fetch('/api/collectData', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ip, id })
                });

                const result = await response.json();

                if (response.ok) {
                    statusEl.innerHTML = `<div style="color: #0f0;">‚úì Daten erfolgreich gesammelt!</div>`;
                    setTimeout(() => {
                        statusEl.remove();
                        loadZustand(); // Tabelle aktualisieren
                    }, 2000);
                } else {
                    statusEl.innerHTML = `<div style="color: #ff6b6b;">‚úó Fehler: ${result.error || 'Daten konnten nicht gesammelt werden'}</div>`;
                    setTimeout(() => statusEl.remove(), 3000);
                }
            } catch (error) {
                console.error('[COLLECT] Fehler:', error);
                statusEl.innerHTML = `<div style="color: #ff6b6b;">‚úó Fehler: ${error.message}</div>`;
                setTimeout(() => statusEl.remove(), 3000);
            }
        }

        // Funktion zum Wiederherstellen der SSH-Schl√ºssel (connectSSH)
        async function restoreSSHKey(ip, id) {
            const statusEl = document.createElement('div');
            statusEl.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #333;
                color: #0f0;
                padding: 20px;
                border-radius: 8px;
                z-index: 9999;
                text-align: center;
                font-family: monospace;
                min-width: 300px;
            `;
            statusEl.innerHTML = `<div>Stelle SSH Schl√ºssel f√ºr ${ip} wieder her...</div><div style="margin-top: 15px; font-size: 14px; color: #aaa;">Bitte warten...</div>`;
            document.body.appendChild(statusEl);

            try {
                const response = await fetch('/api/action', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ ip, action: 'connectSSH' })
                });

                const result = await response.json();

                if (response.ok) {
                    statusEl.innerHTML = `<div style="color: #0f0;">‚úì SSH Schl√ºssel erfolgreich restauriert!</div>`;
                    setTimeout(() => {
                        statusEl.remove();
                        loadZustand(); // Tabelle aktualisieren
                    }, 2000);
                } else {
                    statusEl.innerHTML = `<div style="color: #ff6b6b;">‚úó Fehler: ${result.error || 'SSH Schl√ºssel konnten nicht restauriert werden'}</div>`;
                    setTimeout(() => statusEl.remove(), 3000);
                }
            } catch (error) {
                console.error('[SSH-RESTORE] Fehler:', error);
                statusEl.innerHTML = `<div style="color: #ff6b6b;">‚úó Fehler: ${error.message}</div>`;
                setTimeout(() => statusEl.remove(), 3000);
            }
        }

        // Funktion zum Starten des Updateprozesses (FULL) und zur WebSocket-Verbindung
        async function updateServer(ip) {
            openPopup();

            // WebSocket-Verbindung herstellen
            ws = new WebSocket(`ws://${location.host}`);

            // Beim √ñffnen des WebSockets nur Start-Log-Nachricht anzeigen
            ws.onopen = () => {
                document.getElementById('updateLog').textContent = `WebSocket-Verbindung hergestellt.\nStarte FULL Update auf ${ip}...\n`;
                scrollToBottom();
            };

            // Nachrichten empfangen und im Log anzeigen
            ws.onmessage = (event) => {
                const log = document.getElementById('updateLog');
                log.textContent += event.data + '\n';
                scrollToBottom();
            };

            // Wenn WebSocket-Verbindung geschlossen wird
            ws.onclose = () => {
                const log = document.getElementById('updateLog');
                log.textContent += 'Verbindung geschlossen.';
                scrollToBottom();
                location.reload();
            };

            // Sende die Update-Anfrage an den Server SOFORT
            await fetch('/api/action', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ ip, action: 'updateServer' })
            });
        }

        // Funktion, die durch den "Select Updates" Button aufgerufen wird
        async function selupd(ip, id) {
            const response = await fetch(`/api/serverupdates/${id}`);
            const updates = await response.json();

            if (updates && updates.length > 0 && Array.isArray(updates)) {
                openSelectPopup(ip, updates, id);
            } else {
                alert(`Keine Updates f√ºr ${ip} gefunden.`);
            }
        }

        // Funktion zum Starten des ausgew√§hlten Updateprozesses
        async function startSelectedUpdate() {
            const selectedCheckboxes = document.querySelectorAll('#updateCheckboxes input[name="selectedUpdate"]:checked');
            const packagesToUpdate = Array.from(selectedCheckboxes).map(cb => cb.value);
            const errorDisplay = document.getElementById('selectedUpdateError');

            if (packagesToUpdate.length === 0) {
                errorDisplay.style.display = 'block';
                return;
            }

            if (!currentServerRow || !currentServerRow.ip) {
                console.error("Fehler: Serverinformationen fehlen.");
                alert("Fehler: Serverinformationen konnten nicht abgerufen werden.");
                closeSelectPopup();
                return;
            }

            const ip = currentServerRow.ip;

            errorDisplay.style.display = 'none';
            closeSelectPopup();

            openPopup();

            ws = new WebSocket(`ws://${location.host}`);

            ws.onopen = () => {
                document.getElementById('updateLog').textContent = `WebSocket-Verbindung hergestellt.\nStarte gezieltes Update auf ${ip}...\n`;
                scrollToBottom();
            };

            ws.onmessage = (event) => {
                const log = document.getElementById('updateLog');
                log.textContent += event.data + '\n';
                scrollToBottom();
            };

            ws.onclose = () => {
                const log = document.getElementById('updateLog');
                log.textContent += 'Verbindung geschlossen.';
                scrollToBottom();
                location.reload();
            };

            try {
                await fetch('/api/action', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        ip,
                        action: 'updateSelected',
                        packages: packagesToUpdate
                    })
                });
            } catch (error) {
                console.error("Fehler beim Senden der Update-Aktion an den Server:", error);
                document.getElementById('updateLog').textContent += `\nFEHLER: Konnte die Update-Aktion nicht starten. √úberpr√ºfen Sie die Server-Logs.`;
                scrollToBottom();
            }
        }

        // Funktion zum Ausf√ºhren einer SSH-Verbindung oder anderer Aktionen
        async function executeAction(ip, action) {
            // NEU: Zeige das Log-Popup an, wenn "connectSSH" ausgef√ºhrt wird, damit der Benutzer wei√ü, dass etwas passiert
            if (action === 'connectSSH') {
                openPopup();
                document.getElementById('updateLog').textContent = `Starte SSH-Verbindung zu ${ip} und Datensammlung...`;
            }

            await fetch('/api/action', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ ip, action })
            });

            // Bei connectSSH muss man kurz warten, bis das Skript durchgelaufen ist, bevor man neu l√§dt
            if (action === 'connectSSH') {
                // Wir schlie√üen das Log nach 3 Sekunden und laden neu, da das Backend-Skript nicht mit dem WebSocket verbunden ist
                setTimeout(() => {
                    closePopup();
                    loadZustand();
                }, 3000);
            } else {
                loadZustand();
            }
        }

        // --- REMOTE CONSOLE (SSH) FUNKTIONEN ---

        let sshSocket = null;
        let currentSSHHost = '';
        let terminalInstance = null;

        // Lade xterm.js von lokalen node_modules
        function loadXtermLibraries() {
            return Promise.all([
                new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = '/node_modules/xterm/lib/xterm.js';
                    script.onload = resolve;
                    script.onerror = reject;
                    document.head.appendChild(script);
                }),
                new Promise((resolve, reject) => {
                    const link = document.createElement('link');
                    link.rel = 'stylesheet';
                    link.href = '/node_modules/xterm/css/xterm.css';
                    link.onload = resolve;
                    link.onerror = reject;
                    document.head.appendChild(link);
                })
            ]);
        }

        async function openRemoteConsole(host) {
            console.log('[CONSOLE] √ñffne Remote Console f√ºr:', host);
            currentSSHHost = host;
            document.getElementById('remoteConsolePopup').style.display = 'block';
            document.getElementById('remoteConsoleTitle').textContent = `Remote Console: ${host}`;
            document.getElementById('sshUsername').value = '';
            document.getElementById('sshPassword').value = '';
            document.getElementById('sshAuthStatus').style.display = 'none';
            document.getElementById('authForm').style.display = 'block';

            try {
                // Lade xterm.js wenn noch nicht geladen
                if (typeof Terminal === 'undefined') {
                    console.log('[CONSOLE] Lade xterm.js...');
                    await loadXtermLibraries();
                }

                // Initialisiere Terminal
                const container = document.getElementById('terminalContainer');
                container.innerHTML = '';

                if (typeof Terminal !== 'undefined') {
                    // Nutze xterm.js wenn verf√ºgbar
                    terminalInstance = new Terminal({
                        cols: 120,
                        rows: 30,
                        theme: {
                            background: '#000000',
                            foreground: '#00ff00'
                        },
                        fontFamily: '"Courier New", monospace',
                        fontSize: 12,
                        cursorBlink: true
                    });
                    
                    terminalInstance.open(container);
                    terminalInstance.write('Bereit zur Verbindung. Bitte Anmeldedaten eingeben.\r\n');
                    console.log('[CONSOLE] xterm.js Terminal initialisiert');
                } else {
                    // Fallback auf einfaches HTML-Terminal
                    console.log('[CONSOLE] xterm.js nicht verf√ºgbar, nutze HTML-Terminal');
                    terminalInstance = createSimpleTerminal();
                }
                
            } catch (error) {
                console.error('[CONSOLE] Fehler beim Laden von xterm.js:', error);
                // Fallback auf einfaches Terminal
                terminalInstance = createSimpleTerminal();
            }
        }

        function createSimpleTerminal() {
            const container = document.getElementById('terminalContainer');
            container.innerHTML = '';

            const screen = document.createElement('div');
            screen.id = 'terminalScreen';
            screen.style.cssText = `
                background: #000;
                color: #0f0;
                font-family: 'Courier New', monospace;
                font-size: 12px;
                padding: 10px;
                overflow-y: auto;
                height: calc(100% - 35px);
                white-space: pre-wrap;
                word-wrap: break-word;
                border-bottom: 1px solid #333;
                line-height: 1.4;
            `;

            const input = document.createElement('input');
            input.id = 'terminalInput';
            input.type = 'text';
            input.style.cssText = `
                background: #000;
                color: #0f0;
                border: none;
                outline: none;
                font-family: 'Courier New', monospace;
                font-size: 12px;
                padding: 5px;
                width: 100%;
                box-sizing: border-box;
            `;
            input.placeholder = 'Tippe Befehl ein und dr√ºcke Enter...';

            container.appendChild(screen);
            container.appendChild(input);

            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    const cmd = input.value + '\n';
                    if (sshSocket && sshSocket.readyState === WebSocket.OPEN) {
                        sshSocket.send(JSON.stringify({ type: 'input', data: cmd }));
                    }
                    input.value = '';
                }
            });

            input.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.key === 'c') {
                    e.preventDefault();
                    if (sshSocket && sshSocket.readyState === WebSocket.OPEN) {
                        sshSocket.send(JSON.stringify({ type: 'input', data: '\x03' }));
                    }
                }
                if (e.ctrlKey && e.key === 'l') {
                    e.preventDefault();
                    screen.textContent = '';
                }
            });

            return {
                write: (text) => {
                    const screen = document.getElementById('terminalScreen');
                    if (screen) {
                        screen.textContent += text;
                        screen.scrollTop = screen.scrollHeight;
                    }
                },
                clear: () => {
                    const screen = document.getElementById('terminalScreen');
                    if (screen) {
                        screen.textContent = '';
                    }
                },
                focus: () => {
                    const input = document.getElementById('terminalInput');
                    if (input) {
                        input.focus();
                    }
                }
            };
        }

        function closeRemoteConsole() {
            console.log('[CONSOLE] Schlie√üe Remote Console');
            document.getElementById('remoteConsolePopup').style.display = 'none';
            if (sshSocket) {
                console.log('[CONSOLE] Schlie√üe WebSocket');
                sshSocket.close();
                sshSocket = null;
            }
            if (terminalInstance && terminalInstance.dispose) {
                terminalInstance.dispose();
            }
            terminalInstance = null;
            console.log('[CONSOLE] Remote Console geschlossen');
        }

        async function connectSSHTerminal() {
            const username = document.getElementById('sshUsername').value.trim();
            const password = document.getElementById('sshPassword').value;
            const statusEl = document.getElementById('sshAuthStatus');

            if (!username || !password) {
                statusEl.textContent = 'Benutzername und Passwort erforderlich.';
                statusEl.style.display = 'block';
                return;
            }

            if (!terminalInstance) {
                console.error('[SSH] Terminal noch nicht initialisiert');
                statusEl.textContent = 'Terminal-Fehler. Bitte Fenster neu √∂ffnen.';
                statusEl.style.display = 'block';
                return;
            }

            try {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/api/ssh-terminal/${currentSSHHost}/${encodeURIComponent(username)}`;

                console.log('[SSH] Verbinde zu:', wsUrl);

                if (terminalInstance.clear) {
                    terminalInstance.clear();
                } else if (terminalInstance.write) {
                    terminalInstance.write('\x1Bc'); // ANSI clear screen
                }
                
                terminalInstance.write(`Verbinde zu ${username}@${currentSSHHost}...\r\n`);

                sshSocket = new WebSocket(wsUrl);

                sshSocket.onopen = () => {
                    console.log('[SSH] WebSocket ge√∂ffnet');
                    sshSocket.send(JSON.stringify({ type: 'auth', password: password }));
                    document.getElementById('authForm').style.display = 'none';
                    terminalInstance.write('Authentifizierung gesendet...\r\n');
                    
                    // Wenn xterm.js: registriere keyboard-Input
                    if (terminalInstance.onData) {
                        terminalInstance.onData((data) => {
                            if (sshSocket && sshSocket.readyState === WebSocket.OPEN) {
                                sshSocket.send(JSON.stringify({ type: 'input', data: data }));
                            }
                        });
                    } else if (terminalInstance.focus) {
                        terminalInstance.focus();
                    }

                    setTimeout(() => {
                        if (terminalInstance && terminalInstance.focus) {
                            terminalInstance.focus();
                        }
                    }, 500);
                };

                sshSocket.onmessage = (event) => {
                    const msg = JSON.parse(event.data);
                    if (msg.type === 'output' && terminalInstance) {
                        terminalInstance.write(msg.data);
                    } else if (msg.type === 'error') {
                        console.error('[SSH] Server-Fehler:', msg.data);
                        if (terminalInstance) {
                            terminalInstance.write(`\r\n[FEHLER] ${msg.data}\r\n`);
                        }
                        statusEl.textContent = msg.data;
                        statusEl.style.display = 'block';
                        document.getElementById('authForm').style.display = 'block';
                    }
                };

                sshSocket.onerror = (err) => {
                    console.error('[SSH] WebSocket-Fehler:', err);
                    if (terminalInstance) {
                        terminalInstance.write('\r\n[FEHLER] Verbindungsfehler\r\n');
                    }
                    statusEl.textContent = 'WebSocket-Verbindungsfehler';
                    statusEl.style.display = 'block';
                    document.getElementById('authForm').style.display = 'block';
                };

                sshSocket.onclose = () => {
                    console.log('[SSH] WebSocket geschlossen');
                    if (terminalInstance) {
                        terminalInstance.write('\r\n[INFO] Verbindung geschlossen.\r\n');
                    }
                    document.getElementById('authForm').style.display = 'block';
                };
            } catch (error) {
                console.error('[SSH] Fehler:', error);
                statusEl.textContent = `Fehler: ${error.message}`;
                statusEl.style.display = 'block';
            }
        }

        // Initiales Laden der Zustandsdaten
        loadZustand();


// index.js (oder Ihre Frontend-JS-Datei)

let globalCurlCommand = ''; // Speichert den abgerufenen Curl-Befehl

/**
 * Ruft den Curl-Befehl vom Server ab und zeigt ihn in einem Textfeld an.
 */
async function loadBootstrapCommand() {
    const bootstrapField = document.getElementById('bootstrapCommandField');

    try {
        const response = await fetch('/api/config');
        const data = await response.json();

        // Den Befehl im Textfeld anzeigen
        bootstrapField.value = data.curlCommand;
        console.log("Bootstrap-Befehl erfolgreich geladen.");

    } catch (error) {
        console.error('Fehler beim Laden des Curl-Befehls:', error);
        bootstrapField.value = 'Fehler beim Laden des Bootstrap-Befehls';
    }
}

/**
 * W√§hlt den Text im Textfeld aus (optional - f√ºr bessere Benutzererfahrung).
 */
function selectBootstrapCommand() {
    const bootstrapField = document.getElementById('bootstrapCommandField');
    bootstrapField.select();
}

// RUFE DIE FUNKTION BEIM START AUF
document.addEventListener('DOMContentLoaded', loadBootstrapCommand);





// index.html (oder index.js im public-Ordner)

async function initDashboard() {
    try {
        // 1. Rufe den gesch√ºtzten Status-Endpunkt auf
        const response = await fetch('/api/status');

        if (response.status === 401) {
             // Wenn der Server 401 (Nicht authentifiziert) zur√ºckgibt, zur Login-Seite leiten.
             window.location.href = '/login.html';
             return;
        }

        const data = await response.json();

    if (!data.loggedIn) {
        // ... (Redirect) ...
    }

    // 2. Dashboard erfolgreich initialisieren
    document.getElementById('currentUsername').textContent = data.username || 'Benutzer';

    // 3. Initialisiere Admin-Bereich (Jetzt nur den Button anzeigen)
    if (data.isAdmin) {
        // Macht den Benutzerverwaltungs-Button im Header sichtbar
        document.getElementById('userManagementButton').style.display = 'inline-block';
    }

        // 4. Initialisiere den Bootstrap-Button
        loadBootstrapCommand();

    } catch (error) {
        console.error('Initialisierungsfehler:', error);
        // Fallback bei Netzwerkfehlern
        window.location.href = '/login.html';
    }
}

// Rufen Sie die neue Initialisierungsfunktion beim Start auf



// --- AUTHENTIFIZIERUNGS-FUNKTIONEN ---

async function handleLogout() {
    await fetch('/api/logout', { method: 'POST' });
    // Nach Logout zur Anmeldeseite weiterleiten
    window.location.href = '/login.html';
}

function renderUserManagement() {
    // Hier k√∂nnen Sie sp√§ter Code hinzuf√ºgen, um Admin-Inhalte zu laden.
    // Im Moment dient es nur dazu, den ReferenceError zu verhindern.
    const adminDiv = document.getElementById('userManagementSection');
    adminDiv.innerHTML = '<p>Die Benutzerverwaltung wird hier bald geladen...</p>';
    console.log("Admin-Bereich: renderUserManagement aufgerufen.");
}

// Hilfsfunktion zum Auslesen von Cookies (f√ºr Username/Admin-Status)
function getCookie(name) {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
    return null;
}

// Rufen Sie die neue Initialisierungsfunktion beim Start auf
document.addEventListener('DOMContentLoaded', initDashboard);



function openChangePasswordPopup() {
    // Felder leeren und Status zur√ºcksetzen
    document.getElementById('oldPassword').value = '';
    document.getElementById('newPassword').value = '';
    document.getElementById('confirmNewPassword').value = '';
    document.getElementById('passwordChangeStatus').textContent = '';
    document.getElementById('passwordChangeStatus').style.color = 'red';

    document.getElementById('changePasswordPopup').style.display = 'block';
}

/**
 * Schlie√üt das Pop-up zum √Ñndern des Passworts.
 */
function closeChangePasswordPopup() {
    document.getElementById('changePasswordPopup').style.display = 'none';
}

/**
 * Sendet die Anfrage zur Passwort√§nderung an den Server.
 */
async function submitChangePassword() {
    const oldPassword = document.getElementById('oldPassword').value;
    const newPassword = document.getElementById('newPassword').value;
    const confirmNewPassword = document.getElementById('confirmNewPassword').value;
    const statusDisplay = document.getElementById('passwordChangeStatus');

    statusDisplay.textContent = ''; // Status zur√ºcksetzen

    if (newPassword.length < 6) { // Beispiel: Mindestl√§nge 6 Zeichen
        statusDisplay.textContent = 'Das neue Passwort muss mindestens 6 Zeichen lang sein.';
        return;
    }

    if (newPassword !== confirmNewPassword) {
        statusDisplay.textContent = 'Die neuen Passw√∂rter stimmen nicht √ºberein.';
        return;
    }

    statusDisplay.style.color = 'blue';
    statusDisplay.textContent = 'Wird aktualisiert...';

    try {
        const response = await fetch('/api/changePassword', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ oldPassword, newPassword })
        });

        const result = await response.json();

        if (result.success) {
            statusDisplay.style.color = 'green';
            statusDisplay.textContent = 'Passwort erfolgreich ge√§ndert!';
            // Pop-up nach kurzer Zeit schlie√üen
            setTimeout(closeChangePasswordPopup, 2000);
        } else {
            statusDisplay.style.color = 'red';
            statusDisplay.textContent = result.message || 'Fehler beim √Ñndern des Passworts.';
        }

    } catch (error) {
        statusDisplay.style.color = 'red';
        statusDisplay.textContent = 'Netzwerkfehler beim √Ñndern des Passworts.';
        console.error('Passwort-√Ñnderungsfehler:', error);
    }
}

// *** WICHTIG: Event-Listener zuweisen ***
document.addEventListener('DOMContentLoaded', () => {
    // ... Ihr vorhandener Code ...

    // NEU: Listener f√ºr den Passwort-Button
    const changeButton = document.getElementById('changePasswordButton');
    if (changeButton) {
        changeButton.addEventListener('click', openChangePasswordPopup);
    }
});



// --- BENUTZERVERWALTUNGS FUNKTIONEN ---

function openUserManagementPopup() {
    document.getElementById('userManagementPopup').style.display = 'block';
    loadUsers(); // L√§dt die aktuelle Benutzerliste, sobald das Pop-up ge√∂ffnet wird
}

function closeUserManagementPopup() {
    document.getElementById('userManagementPopup').style.display = 'none';
    document.getElementById('userCreationStatus').textContent = '';
}

/**
 * Ruft die Benutzerliste vom Server ab und f√ºllt die Tabelle.
 */
async function loadUsers() {
    const tableBody = document.getElementById('userTableBody');
    tableBody.innerHTML = '<tr><td colspan="4">Lade Benutzer...</td></tr>';

    try {
        const response = await fetch('/api/users');
        if (response.status === 403) {
             tableBody.innerHTML = '<tr><td colspan="4" style="color:red;">Keine Berechtigung zur Anzeige.</td></tr>';
             return;
        }

        const users = await response.json();
        tableBody.innerHTML = '';

        users.forEach(user => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td>${user.id}</td>
                <td>${user.username}</td>
                <td>${user.is_admin ? 'Ja' : 'Nein'}</td>
                <td>
                    <button class="action-button" style="padding: 6px 12px; font-size: 14px; background-color: #d9534f;" onclick="deleteUser(${user.id}, '${user.username}')">üóëÔ∏è L√∂schen</button>
                </td>
            `;
            tableBody.appendChild(tr);
        });

    } catch (error) {
        console.error('Fehler beim Laden der Benutzer:', error);
        tableBody.innerHTML = '<tr><td colspan="4" style="color:red;">Fehler beim Laden der Daten.</td></tr>';
    }
}

/**
 * Erstellt einen neuen Benutzer.
 */
async function createUser() {
    const username = document.getElementById('newUsername').value.trim();
    const password = document.getElementById('newUserPassword').value;
    const isAdmin = document.getElementById('newUserIsAdmin').checked;
    const statusDisplay = document.getElementById('userCreationStatus');

    if (!username || !password || password.length < 6) {
        statusDisplay.textContent = 'Bitte Benutzername und ein Passwort (min. 6 Zeichen) eingeben.';
        return;
    }

    try {
        const response = await fetch('/api/createUser', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ username, password, isAdmin })
        });

        const result = await response.json();

        if (result.success) {
            statusDisplay.style.color = 'green';
            statusDisplay.textContent = `Benutzer ${username} erfolgreich erstellt!`;
            // Formular leeren
            document.getElementById('newUsername').value = '';
            document.getElementById('newUserPassword').value = '';
            document.getElementById('newUserIsAdmin').checked = false;
            loadUsers(); // Liste aktualisieren
        } else {
            statusDisplay.style.color = 'red';
            statusDisplay.textContent = result.message || 'Fehler beim Erstellen des Benutzers.';
        }
    } catch (error) {
        statusDisplay.style.color = 'red';
        statusDisplay.textContent = 'Netzwerkfehler beim Erstellen.';
        console.error('Fehler beim Erstellen:', error);
    }
}

/**
 * L√∂scht einen Benutzer nach Best√§tigung.
 */
async function deleteUser(id, username) {
    // Verhindere das L√∂schen des eigenen Kontos (optional)
    const currentUsername = document.getElementById('currentUsername').textContent;
    if (username === currentUsername) {
        alert("Sie k√∂nnen Ihr eigenes aktuell eingeloggtes Konto nicht l√∂schen.");
        return;
    }

    if (confirm(`Soll der Benutzer ${username} (ID: ${id}) wirklich gel√∂scht werden?`)) {
        try {
            const response = await fetch('/api/deleteUser', {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id })
            });

            const result = await response.json();

            if (result.success) {
                alert(`Benutzer ${username} erfolgreich gel√∂scht.`);
                loadUsers(); // Liste aktualisieren
            } else {
                alert(result.message || 'Fehler beim L√∂schen des Benutzers.');
            }
        } catch (error) {
            console.error('Fehler beim L√∂schen:', error);
            alert('Netzwerkfehler beim L√∂schen des Benutzers.');
        }
    }
}

    </script>

    <!-- SSH Remote Console Modal -->
    <div id="remoteConsolePopup" class="popup" style="display: none;">
        <div class="popup-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h2 id="remoteConsoleTitle" style="margin: 0;">Remote Console</h2>
                <span id="closeRemoteConsole" onclick="closeRemoteConsole()" style="cursor: pointer; font-size: 28px; color: #ccc;">&times;</span>
            </div>
            <div id="terminalContainer" style="background: #000;"></div>
            <div id="authForm" style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                <input type="text" id="sshUsername" placeholder="SSH Benutzername" required style="padding: 8px; flex: 0 1 auto;">
                <input type="password" id="sshPassword" placeholder="SSH Passwort" required style="padding: 8px; flex: 0 1 auto;">
                <button class="action-button" onclick="connectSSHTerminal()" style="flex: 0 0 auto;">Verbinden</button>
                <p id="sshAuthStatus" style="color: #ff6b6b; margin: 0; font-size: 12px; width: 100%; display: none;"></p>
            </div>
        </div>
    </div>

</body>
</html>
